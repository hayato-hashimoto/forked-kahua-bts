;; -*- coding: euc-jp; mode: kahua -*-
;;
;;  Copyright (c) 2005 Kahua.Org, All rights reserved.
;;  See COPYING for terms and conditions of using this software
;;
;; $Id: gadget.kahua,v 1.50 2006/02/11 13:51:37 cut-sea Exp $
;;
(define $property-list$
  (list "priority" "status" "type" "category" "assign"))

(define $full-property-list$
  (list "fans" "priority" "status" "type" "category" "assign"))

(define $property-accessor-list$
  (list priority-of status-of type-of category-of assign-of))

(define $properties-accessor-list$
  (list priorities-of statuss-of types-of categories-of fans-of))

(define $all-properties-list$
  (list all-priorities all-statuss all-types all-categories all-fans))

(define $property-headers$
  (map $$ '("優先度" "ステータス" "タイプ" "カテゴリ" "アサイン")))

(define (sendmail-lite unit musume song)
  (and-let* ((fans (filter (lambda (fan)
			     (not (or (equal? "   " (fan-name-of fan))
                                      (string-null? (email-address-of fan))
                                      (memq unit (unsubscriptions-of fan)))))
			   (fans-of unit))))
    (let* ((addresses (append (map email-address-of fans) (notify-addresses-of unit)))
           (from-name (kahua-current-user-name))
           (from-address (email-address-of (current-fan)))
           (domain (values-ref (uri-parse (kahua-server-uri)) 2))
           (subject #`"[,(unit-name-of unit)] ,(mno-of musume):,(mname-of musume)")
           (message-id #`"<,(key-of unit),(key-of musume),(key-of song)@,|domain|>")
           (reply-to (let1 songs (songs-of musume)
                       (and (not (null? (cdr songs)))
                            #`"<,(key-of unit),(key-of musume),(key-of (cadr songs))@,|domain|>")))
	   (body  (string-join
		   (list
		    #`"【 タイトル 】 ,subject"
		    #`"【  ポスト  】 ,(fan-name-of (fan-of song))"
		    #`"【   日時   】 ,(sys-strftime \"%Y/%m/%d %H:%M:%S\" (sys-localtime (ctime-of song)))"
		    #`"【ステータス】 ,(disp-name-of (status-of musume))"
		    #`"【  優先度  】 ,(disp-name-of (priority-of musume))"
		    #`"【  タイプ  】 ,(disp-name-of (type-of musume))"
		    #`"【 カテゴリ 】 ,(disp-name-of (category-of musume))"
		    #`"【 アサイン 】 ,(fan-name-of (assign-of musume))"
		    #`"【   期限   】 ,(if (limit-of musume) (sys-strftime \"%Y/%m/%d\" (sys-localtime (limit-of musume))) \"-\")"
		    #`"【 コメント 】\n\n,(melody-of song)"
		    ""
                    (let1 files (files-of song)
                      (if (null? files)
                          ""
                        #`"FILE: ,(name-of (car files)) -> ,(kahua-server-uri),(uri-of (car files))"))
                    #`"URL: ,(kahua-self-uri-full)melody-list/,(key-of unit)/,(key-of musume)")
                   "\n")))
      (for-each (lambda (address)
		  (sendmail/headers body
                                    :to address
                                    :from #`",|from-name| <,|from-address|>"
                                    :reply-to *kagoiri-musume-email*
                                    :subject subject
                                    :message-id message-id
                                    :in-reply-to reply-to
                                    (make-keyword *x-kagoiri-mail*) (key-of unit)))
		addresses))))

(define (create-new-unit name desc fans priority status type category notify-addresses)
  (and (not (string-null? name))
       (not (null? fans))
       (or (id->obj <unit> name)
	   (make <unit>
	     :unit-name name
	     :description desc
	     :fans (id-list->obj-list <fan> fans)
	     :priorities (id-list->obj-list <priority> priority)
	     :statuss (id-list->obj-list <status> status)
	     :types (id-list->obj-list <type> type)
	     :categories (id-list->obj-list <category> category)
	     :notify-addresses (normalize-addresses notify-addresses)))))

(define (create-new-musume unit name priority status assign type category)
  (make <musume> :unit unit
	:musume-name name
	:priority (id->obj <priority> priority)
	:status (id->obj <status> status)
	:assign (id->obj <fan> assign)
	:type (id->obj <type> type)
	:category (id->obj <category> category)))

(define (create-new-song musume melody fan)
  (make <song> :musume musume
	:melody melody
	:fan fan))

(define (create-new-file name ext path uri)
  (make <file> :file-name name
	:extension ext
	:path path
	:uri uri))

(define (musume-makeover! musume p s t c a d)
  (set! (priority-of musume) (id->obj <priority> p))
  (set! (status-of musume) (id->obj <status> s))
  (set! (type-of musume) (id->obj <type> t))
  (set! (category-of musume) (id->obj <category> c))
  (set! (assign-of musume) (id->obj <fan> a))
  (set! (limit-of musume) d)
  musume)

(define (unit-makeover! unit n d notify fs ps ss ts cs)
  (if (not (string-null? n))
      (set! (unit-name-of unit) n))
  (set! (description-of unit) d)
  (set! (fans-of unit) (id-list->obj-list <fan> fs))
  (set! (priorities-of unit) (id-list->obj-list <priority> ps))
  (set! (statuss-of unit) (id-list->obj-list <status> ss))
  (set! (types-of unit) (id-list->obj-list <type> ts))
  (set! (categories-of unit) (id-list->obj-list <category> cs))
  (set! (notify-addresses-of unit) (normalize-addresses (kahua-context-ref "notify-addresses")))
  unit)

(define (uploaded-file-name unit musume song)
  #`",(ref unit 'id)_,(ref musume 'id)_,(ref song 'id)")

(define (attach-file song file upload-name)
  (if file
      (let* ((tmp-path (car file))
	     (file-name (sys-basename (cadr file)))
	     (file-xtnsn (let1 body+ext (string-split file-name ".")
			   (if (= (length body+ext) 1)
			       "" (last body+ext))))
	     (real-name (if (equal? file-xtnsn "")
			    #`",upload-name"
			    #`",|upload-name|.,file-xtnsn"))
	     (file-path #`",|*kagoiri-musume-upload-path*|/,real-name")
	     (file-uri #`",|*kagoiri-musume-upload-uri*|/,real-name"))
	(make-directory* *kagoiri-musume-upload-path* #o775)
	(copy-file tmp-path file-path)
	;; now, just one file upload support, but...
	(set! (files-of song)
	      (list (create-new-file file-name file-xtnsn file-path file-uri))))))


;; for error message
;;
(define %error% (make-parameter #f))
(define (error?) (%error%))
;; (define (get-error-message) (or (%error%) ""))
(define (set-error-message msg) (%error% msg))


(define (focus_focus)
  (script/ (@/ (type "text/javascript"))
           "addOnloadEvent(focus_focus)"))

;; for jisx0201 half kana
;;
(use srfi-1)
(use gauche.collection)

(define (make-table src . dst)
  (let1 dst (get-optional dst (make-list (string-length src) #t))
    (let ((pairs (map cons src dst))
	  (tbl (make-hash-table)))
      (for-each (lambda (kv)
		  (hash-table-put! tbl (car kv) (cdr kv)))
		pairs)
      tbl)))

(define (gen-kana-trans . options)
  (let-keywords* options ((loseless-voices :voiced #t)
                          (loseless-semivoices :semivoiced #t))
    (let* ((normal (make-table
                    "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜｦﾝｧｨｩｪｫｬｭｮｯｰ､｡｢｣･"
                    "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲンァィゥェォャュョッー、。「」・"))
           (voiced (make-table
                    "ｳｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾊﾋﾌﾍﾎ"
                    "ヴガギグゲゴザジズゼゾダヂヅデドバビブベボ"))
           (semivoiced (make-table
                        "ﾊﾋﾌﾍﾎ"
                        "パピプペポ"))
           (voiced-loseless? (if (string? loseless-voices) #f #t))
           (semivoiced-loseless? (if (string? loseless-semivoices) #f #t))
           (vs (if voiced-loseless?
                   (make-hash-table)
                   (make-table loseless-voices)))
           (svs (if semivoiced-loseless?
                    (make-hash-table)
                    (make-table loseless-semivoices))))
      (lambda (orig-string)
        (let lp ((rev-str (reverse (string->list orig-string)))
                 (result '()))
          (if (null? rev-str)
              (list->string result)
              (let ((c (car rev-str))
                    (rest (cdr rev-str)))
                (cond ((eq? c #\ﾞ) (cond ((null? rest) (if voiced-loseless?
                                                           (lp rest (cons #\゛ result))
                                                           (lp rest result)))
                                         ((hash-table-get voiced (car rest) #f) => (lambda (v) (lp (cdr rest) (cons v result))))
                                         ((hash-table-get vs (car rest) voiced-loseless?) (lp rest (cons #\゛ result)))
                                         (else (lp rest result))))
                      ((eq? c #\ﾟ) (cond ((null? rest) (if semivoiced-loseless?
                                                           (lp rest (cons #\゜ result))
                                                           (lp rest result)))
                                         ((hash-table-get semivoiced (car rest) #f) => (lambda (v) (lp (cdr rest) (cons v result))))
                                         ((hash-table-get svs (car rest) semivoiced-loseless?) (lp rest (cons #\゜ result)))
                                         (else (lp rest result))))
                      ((hash-table-get normal c #f) => (lambda (v) (lp rest (cons v result))))
                      (else (lp rest (cons c result)))))))))))

(define kana-trans:half->full (gen-kana-trans))
