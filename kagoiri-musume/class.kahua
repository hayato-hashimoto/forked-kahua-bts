;; -*- coding: euc-jp; mode: scheme -*-
;;
;;  Copyright (c) 2005 Kahua.Org, All rights reserved.
;;  See COPYING for terms and conditions of using this software
;;
;; $Id: class.kahua,v 1.34 2005/10/26 18:26:59 cut-sea Exp $
;;
;; include

(load "kagoiri-musume/user-setting.kahua")

;; Unit means Project.
;;
(define-class <unit> (<kahua-persistent-base>)
  (
   ;; unit name means project name.
   (unit-name       :allocation :persistent :init-keyword :unit-name
		    :accessor unit-name-of)
   (description     :allocation :persistent :init-keyword :description
		    :init-value "" :accessor description-of)
   ;; counter of musume as issue.
   (next-musume-no  :allocation :persistent :init-keyword :next-musume-no
		    :init-value 1 :accessor next-musume-no-of)
   ;; fans means developers.
   (fans            :allocation :persistent :init-keyword :fans
		    :init-value '() :accessor fans-of)
   ;; priorities
   (priorities      :allocation :persistent :init-keyword :priorities
		    :init-value '() :accessor priorities-of)
   ;; statuss
   (statuss         :allocation :persistent :init-keyword :statuss
		    :init-value '() :accessor statuss-of)
   ;; types
   (types           :allocation :persistent :init-keyword :types
		    :init-value '() :accessor types-of)
   ;; categories
   (categories      :allocation :persistent :init-keyword :categories
		    :init-value '() :accessor categories-of)
   (ctime           :allocation :persistent :init-keyword :ctime
		    :init-thunk sys-time :accessor ctime-of)
   ;; delete flag
   (fallout         :allocation :persistent :init-keyword :fallout
		    :init-value #f :accessor fallout-of)
   ))

(define (active? unit)
  (not (fallout-of unit)))

(define (all-units)
  (filter active?
	  (make-kahua-collection <unit>)))

;; Musume means issue.
;;
(define-class <musume> (<kahua-persistent-base>)
  (
   ;; new slot
   (unit            :allocation :persistent :init-keyword :unit
		    :accessor unit-of)
   ;; musume-no means issue number.
   (musume-no       :allocation :persistent :init-keyword :musume-no
		    :init-value #f :accessor mno-of)
   ;; issue title
   (musume-name     :allocation :persistent :init-keyword :musume-name
		    :init-value "" :accessor mname-of)
   ;; issue priority
   ;; normal above-normal low high super
   (priority        :allocation :persistent :init-keyword :priority
		    :init-value "normal" :accessor priority-of)
   ;; status
   ;; open completed on-hold taken rejected
   (status          :allocation :persistent :init-keyword :status
		    :init-value "open" :accessor status-of)
   ;; type
   ;; discuss request bug report task term etc
   (type            :allocation :persistent :init-keyword :type
		    :init-value #f :accessor type-of)
   ;; category
   ;;
   (category        :allocation :persistent :init-keyword :category
		    :initi-value #f :accessor category-of)
   ;; assign
   (assign          :allocation :persistent :init-keyword :assign
		    :init-value #f :accessor assign-of)
   ;; songs
   (songs           :allocation :persistent :init-keyword :songs
		    :init-value '() :accessor songs-of)
   ;; create time
   (ctime           :allocation :persistent :init-keyword :ctime
		    :init-thunk sys-time :accessor ctime-of)
   ))

(define-method initialize ((obj <musume>) initargs)
  (next-method)
  (let* ((unit (unit-of obj))
	 (mno (next-musume-no-of unit)))
    ;; for restart
    (if (not (mno-of obj))
	(begin
	  (set! (mno-of obj) mno)
	  (set! (next-musume-no-of unit) (+ mno 1))))))

(define-method next-seq-no ((obj <musume>))
  (+ 1 (length (songs-of obj))))

(define-method all-musumes ((unit <unit>))
  (filter (lambda (m)
	    (eq? unit (unit-of m)))
	  (make-kahua-collection <musume>)))

;; song means one of issue.
;;
(define-class <song> (<kahua-persistent-base>)
  ((seq-no          :allocation :persistent :init-keyword :seq-no
		    :init-value #f :accessor seq-no-of)
   (musume          :allocation :persistent :init-keyword :musume
		    :accessor musume-of)
   (melody          :allocation :persistent :init-keyword :melody
		    :accessor melody-of)
   (files           :allocation :persistent :init-keyword :files
		    :init-value '() :accessor files-of)
   (fan             :allocation :persistent :init-keyword :fan
		    :init-value #f :accessor fan-of)
   (ctime           :allocation :persistent :init-keyword :ctime
		    :init-thunk sys-time :accessor ctime-of)
   ))

(define-method initialize ((obj <song>) initargs)
  (next-method)
  (let* ((musume (musume-of obj))
	 (songs (songs-of musume)))
    ;; for restart
    (if (not (seq-no-of obj))
	(begin
	  (set! (seq-no-of obj) (next-seq-no musume))
	  (set! (songs-of musume) (cons obj songs))))))

(define-method all-songs ((musume <musume>))
  (songs-of musume))

;; file
;;
(define-class <file> (<kahua-persistent-base>)
  ((file-name       :allocation :persistent :init-keyword :file-name
		    :accessor name-of)
   (path            :allocation :persistent :init-keyword :path
		    :init-value "" :accessor path-of)
   (extension       :allocation :persistent :init-keyword :extension
		    :init-value "" :accessor extension-of)
   (uri             :allocation :persistent :init-keyword :uri
		    :init-value "" :accessor uri-of)
;  (type            :allocation :persistent :init-keyword :type
;		    :init-value "" :accessor type-of)
;  (size            :allocation :persistent :init-keyword :size
;		    :init-value "" :accessor size-of)
   ))

;; email
;;
(define-class <email> (<kahua-persistent-base>)
  ((address         :allocation :persistent :init-keyword :address
		    :accessor address-of)))

;; fans means developer
;;
(define-class <fan> (<kahua-persistent-base>)
  (
   (login-user      :allocation :persistent :init-keyword :login-user
		    :init-value #f :accessor login-user-of)
   (email           :allocation :persistent :init-keyword :email
		    :init-value #f :accessor email-of)
   ;; delete flag
   (delete          :allocation :persistent :init-keyword :delete
		    :init-value #f :accessor delete-of)
   ))

(define-method email-address-of ((self <fan>))
  (address-of (email-of self)))

(define-method fan-name-of ((self <fan>))
  (ref (login-user-of self) 'login-name))

(define-method key-of ((self <fan>))
  (fan-name-of self))

(define (lucky-fan? fan)
  (not (delete-of fan)))

(define (all-fans)
  (filter lucky-fan?
	  (make-kahua-collection <fan>)))

(define (all-fan-names)
  (map fan-name-of (all-fans)))

(define (add-fan name passwd mail-address . roles)
  (and-let* ((user (kahua-add-user name passwd))
	     (email (make <email> :address mail-address))
	     (fan  (make <fan> :login-user user :email email)))
    (set! (ref user 'role-alist) roles)
    fan))

(define (current-fan)
  (find-kahua-instance <fan> (kahua-current-user-name)))

(define-method fan-to? ((unit <unit>) (fan <fan>))
  (if (memq fan (fans-of unit)) #t #f))

(define-method viewable? ((unit <unit>) . user)
  (let1 fan (find-kahua-instance
	     <fan>
             (ref (if (null? user)
                      (kahua-add-user)
		      (car user)) 'login-name))
    (memq fan (fans-of unit))))

;; alias methods for convenient.
(define-method code-of ((obj <fan>))
  (fan-name-of obj))
(define-method disp-name-of ((obj <fan>))
  (fan-name-of obj))


;; convenient method
;;
(define-method admin? ((user <kahua-user>))
  (if (kahua-user-has-role? user '(admin)) #t #f))

(define-method admin? ((fan <fan>))
  (if (kahua-user-has-role? (login-user-of fan) '(admin)) #t #f))

(define-method common? ((user <kahua-user>))
  (if (kahua-user-has-role? user '(user)) #t #f))

(define-method common? ((fan <fan>))
  (if (kahua-user-has-role? (login-user-of fan) '(user)) #t #f))

(define-method developer? ((user <kahua-user>))
  (if (kahua-user-has-role? user '(developer)) #t #f))

(define-method developer? ((fan <fan>))
  (if (kahua-user-has-role? (login-user-of fan) '(developer)) #t #f))

(define-method client? ((user <kahua-user>))
  (if (kahua-user-has-role? user '(client)) #t #f))

(define-method client? ((fan <fan>))
  (if (kahua-user-has-role? (login-user-of fan) '(client)) #t #f))


;; property base
(define-class <property-base> (<kahua-persistent-base>)
  ((code             :allocation :persistent :init-keyword :code
		     :init-value #f :accessor code-of)
   (disp-name        :allocation :persistent :init-keyword :disp-name
		     :accessor disp-name-of)
   (delete           :allocation :persistent :init-keyword :delete
		     :init-value #f :accessor delete-of)
   ))

(define-method key-of ((self <property-base>))
  (code-of self))

(define-method enable? ((obj <property-base>))
  (not (delete-of obj)))

;; priority property
;;
(define-class <priority> (<property-base>)
  ((level            :allocation :persistent :init-keyword :level
		     :init-value 0 :accessor level-of)
   ))

(define (all-priorities)
  (filter enable? (make-kahua-collection <priority>)))

(define-method has? ((unit <unit>) (priority <priority>))
  (if (memq priority (priorities-of unit)) #t #f))

;; status property
;;
(define-class <status> (<property-base>)
  ())

(define (all-statuss)
  (filter enable? (make-kahua-collection <status>)))

(define-method has? ((unit <unit>) (status <status>))
  (if (memq status (statuss-of unit)) #t #f))

;; type property
;;
(define-class <type> (<property-base>)
  ())

(define (all-types)
  (filter enable? (make-kahua-collection <type>)))

(define-method has? ((unit <unit>) (type <type>))
  (if (memq type (types-of unit)) #t #f))

;; categories property
;;
(define-class <category> (<property-base>)
  ())

(define (all-categories)
  (filter enable? (make-kahua-collection <category>)))

(define-method has? ((unit <unit>) (category <category>))
  (if (memq category (categories-of unit)) #t #f))

(define (id-list->obj-list class ids)
  (map (lambda (id)
         (find-kahua-instance class id))
       ids))

(define (id->obj class id)
  (find-kahua-instance class id))
