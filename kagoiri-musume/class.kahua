;; -*- coding: euc-jp; mode: scheme -*-
;;
;;  Copyright (c) 2005 Kahua.Org, All rights reserved.
;;  See COPYING for terms and conditions of using this software
;;
;; $Id: class.kahua,v 1.48 2005/11/23 09:12:05 shibata Exp $
;;
;; Unit means Project.
;;
(define-class <unit> (<kahua-persistent-base>)
  (
   ;; unit name means project name.
   (unit-name       :allocation :persistent :init-keyword :unit-name
		    :accessor unit-name-of)
   (description     :allocation :persistent :init-keyword :description
		    :init-value "" :accessor description-of)
   ;; counter of musume as issue.
   (next-musume-no  :allocation :persistent :init-keyword :next-musume-no
		    :init-value 1 :accessor next-musume-no-of)
   ;; fans means developers.
   (fans            :allocation :persistent :init-keyword :fans
		    :init-value '() :accessor fans-of)
   ;; priorities
   (priorities      :allocation :persistent :init-keyword :priorities
		    :init-value '() :accessor priorities-of)
   ;; statuss
   (statuss         :allocation :persistent :init-keyword :statuss
		    :init-value '() :accessor statuss-of)
   ;; types
   (types           :allocation :persistent :init-keyword :types
		    :init-value '() :accessor types-of)
   ;; categories
   (categories      :allocation :persistent :init-keyword :categories
		    :init-value '() :accessor categories-of)
   (ctime           :allocation :persistent :init-keyword :ctime
		    :init-thunk sys-time :accessor ctime-of)
   ;; delete flag
   (fallout         :allocation :persistent :init-keyword :fallout
		    :init-value #f :accessor fallout-of)

   (notify-addresses :allocation :persistent :init-keyword :notify-addresses
                     :init-value '() :accessor notify-addresses-of)
   ))

(define (active? unit)
  (not (fallout-of unit)))

(define (all-units)
  (filter active?
	  (make-kahua-collection <unit>)))


(define-method normalize-addresses ((addresses <string>))
  (normalize-addresses
   (string-split addresses "\r\n")))

(define-method normalize-addresses ((addresses <list>))
  (filter (lambda (email) (not (string-null? email))) addresses))

(define-method normalize-addresses ((addresses <boolean>))
  '())


;; Musume means issue.
;;
(define-class <musume> (<kahua-persistent-base>)
  (
   ;; new slot
   (unit            :allocation :persistent :init-keyword :unit
		    :accessor unit-of)
   ;; musume-no means issue number.
   (musume-no       :allocation :persistent :init-keyword :musume-no
		    :init-value #f :accessor mno-of)
   ;; issue title
   (musume-name     :allocation :persistent :init-keyword :musume-name
		    :init-value "" :accessor mname-of)
   ;; issue priority
   ;; normal above-normal low high super
   (priority        :allocation :persistent :init-keyword :priority
		    :init-value "normal" :accessor priority-of)
   ;; status
   ;; open completed on-hold taken rejected
   (status          :allocation :persistent :init-keyword :status
		    :init-value "open" :accessor status-of)
   ;; type
   ;; discuss request bug report task term etc
   (type            :allocation :persistent :init-keyword :type
		    :init-value #f :accessor type-of)
   ;; category
   ;;
   (category        :allocation :persistent :init-keyword :category
		    :initi-value #f :accessor category-of)
   ;; assign
   (assign          :allocation :persistent :init-keyword :assign
		    :init-value #f :accessor assign-of)
   ;; songs
   (songs           :allocation :persistent :init-keyword :songs
		    :init-value '() :accessor songs-of)
   ;; create time
   (ctime           :allocation :persistent :init-keyword :ctime
		    :init-thunk sys-time :accessor ctime-of)
   (delete          :allocation :persistent :init-keyword :delete
		    :init-value #f :accessor delete-of)
   ))

(define-method initialize ((obj <musume>) initargs)
  (next-method)
  (let* ((unit (unit-of obj))
	 (mno (next-musume-no-of unit)))
    ;; for restart
    (if (not (mno-of obj))
	(begin
	  (set! (mno-of obj) mno)
	  (set! (next-musume-no-of unit) (+ mno 1))))))

(define-method next-seq-no ((obj <musume>))
  (+ 1 (length (songs-of obj))))

(define-method all-musumes ((unit <unit>))
  (filter (lambda (m)
	    (eq? unit (unit-of m)))
	  (make-kahua-collection <musume>)))

(define-method all-active-musumes ((unit <unit>))
  (filter (lambda (m)
	    (and (eq? unit (unit-of m))
		 (not (delete-of m))))
	  (make-kahua-collection <musume>)))

(define-method object-compare ((obj1 <musume>) (obj2 <musume>))
  (compare (ctime-of obj1) (ctime-of obj2)))

(define-method compare-value ((obj <musume>) key)
  (case (string->symbol key)
    ((no) (format "~3,'0d" (mno-of obj)))
    ((title) (mname-of obj))
    ((priority) (code-of (priority-of obj)))
    ((status) (code-of (status-of obj)))
    ((assgin) (code-of (assign-of obj)))
    ((type) (code-of (type-of obj)))
    ((category) (code-of (category-of obj)))
    ((ctime) (number->string (ctime-of obj)))
    ((mtime) (number->string (ctime-of (car (songs-of obj)))))
    ))

;; song means one of issue.
;;
(define-class <song> (<kahua-persistent-base>)
  ((seq-no          :allocation :persistent :init-keyword :seq-no
		    :init-value #f :accessor seq-no-of)
   (musume          :allocation :persistent :init-keyword :musume
		    :accessor musume-of)
   (melody          :allocation :persistent :init-keyword :melody
		    :accessor melody-of)
   (files           :allocation :persistent :init-keyword :files
		    :init-value '() :accessor files-of)
   (fan             :allocation :persistent :init-keyword :fan
		    :init-value #f :accessor fan-of)
   (ctime           :allocation :persistent :init-keyword :ctime
		    :init-thunk sys-time :accessor ctime-of)
   (delete          :allocation :persistent :init-keyword :delete
		    :init-value #f :accessor delete-of)
   ))

(define-method initialize ((obj <song>) initargs)
  (next-method)
  (let* ((musume (musume-of obj))
	 (songs (songs-of musume)))
    ;; for restart
    (if (not (seq-no-of obj))
	(begin
	  (set! (seq-no-of obj) (next-seq-no musume))
	  (set! (songs-of musume) (cons obj songs))))))

(define-method object-compare ((obj1 <song>) (obj2 <song>))
  (compare (ctime-of obj1) (ctime-of obj2)))

(define-method all-songs ((musume <musume>))
  (songs-of musume))

(define-method active? ((song <song>))
  (not (delete-of song)))

(define-method all-active-songs ((musume <musume>))
  (filter active? (songs-of musume)))



;; file
;;
(define-class <file> (<kahua-persistent-base>)
  ((file-name       :allocation :persistent :init-keyword :file-name
		    :accessor name-of)
   (path            :allocation :persistent :init-keyword :path
		    :init-value "" :accessor path-of)
   (extension       :allocation :persistent :init-keyword :extension
		    :init-value "" :accessor extension-of)
   (uri             :allocation :persistent :init-keyword :uri
		    :init-value "" :accessor uri-of)
;  (type            :allocation :persistent :init-keyword :type
;		    :init-value "" :accessor type-of)
;  (size            :allocation :persistent :init-keyword :size
;		    :init-value "" :accessor size-of)
   ))

;; email
;;
(define-class <email> (<kahua-persistent-base>)
  ((address         :allocation :persistent :init-keyword :address
		    :accessor address-of)))

;; fans means developer
;;
(define-class <fan> (<kahua-persistent-base>)
  (
   (login-user      :allocation :persistent :init-keyword :login-user
		    :init-value #f :accessor login-user-of)
   (email           :allocation :persistent :init-keyword :email
		    :init-value #f :accessor email-of)
   ;; delete flag
   (delete          :allocation :persistent :init-keyword :delete
		    :init-value #f :accessor delete-of)
   (%properties	    :allocation :persistent
                    :init-value '())
   ))

;; pseudo getter
(define-method slot-missing ((class <class>) (obj <fan>) slot)
  (assq-ref (ref obj '%properties) slot))

;; pseudo setter
(define-method slot-missing ((class <class>) (obj <fan>) slot val)
  (unless (kahua-serializable-object? val)
    (error "attempted to enter unserializable object to <fan>: ~s"
           val))
  (set! (ref obj '%properties)
      (assq-set! (ref obj '%properties) slot val)))

(define-method email-address-of ((self <fan>))
  (address-of (email-of self)))

(define-method fan-name-of ((self <fan>))
  (ref (login-user-of self) 'login-name))

(define-method key-of ((self <fan>))
  (fan-name-of self))

(define (lucky-fan? fan)
  (not (delete-of fan)))

(define (all-fans)
  (filter lucky-fan?
	  (make-kahua-collection <fan>)))

(define (all-fan-names)
  (map fan-name-of (all-fans)))

(define (add-fan name passwd mail-address . roles)
  (and-let* ((user (kahua-add-user name passwd))
	     (email (make <email> :address mail-address))
	     (fan  (make <fan> :login-user user :email email)))
    (set! (ref user 'role-alist) roles)
    fan))

(define (current-fan)
  (find-kahua-instance <fan> (kahua-current-user-name)))

(define-method fan-to? ((unit <unit>) (fan <fan>))
  (if (memq fan (fans-of unit)) #t #f))

(define-method viewable? ((unit <unit>) . user)
  (let1 fan (find-kahua-instance
	     <fan>
             (ref (if (null? user)
                      (kahua-add-user)
		      (car user)) 'login-name))
    (memq fan (fans-of unit))))

;; alias methods for convenient.
(define-method code-of ((obj <fan>))
  (fan-name-of obj))
(define-method disp-name-of ((obj <fan>))
  (fan-name-of obj))

;; hacks for #f
;;
(define-method code-of ((obj <boolean>)) "")
(define-method disp-name-of ((obj <boolean>)) "")
(define-method delete-of ((obj <boolean>)) #t)
(define-method level-of ((obj <boolean>)) 0)

;; convenient method
;;
(define (admin?)
  (kahua-user-has-role? (kahua-current-user) '(admin)))
(define (common?)
  (and (kahua-user-has-role? (kahua-current-user) '(client developer admin))))
(define (developer?)
  (kahua-user-has-role? (kahua-current-user) '(developer)))
(define (client?)
  (kahua-user-has-role? (kahua-current-user) '(client)))

;; property base
(define-class <property-base> (<kahua-persistent-base>)
  ((code             :allocation :persistent :init-keyword :code
		     :init-value #f :accessor code-of)
   (disp-name        :allocation :persistent :init-keyword :disp-name
		     :accessor disp-name-of)
   (delete           :allocation :persistent :init-keyword :delete
		     :init-value #f :accessor delete-of)
   ))

(define-method key-of ((self <property-base>))
  (code-of self))

(define-method enable? ((obj <property-base>))
  (not (delete-of obj)))

;; priority property
;;
(define-class <priority> (<property-base>)
  ((level            :allocation :persistent :init-keyword :level
		     :init-value 0 :accessor level-of)
   ))

(define (all-priorities)
  (filter enable? (make-kahua-collection <priority>)))

(define-method has? ((unit <unit>) (priority <priority>))
  (if (memq priority (priorities-of unit)) #t #f))

;; status property
;;
(define-class <status> (<property-base>)
  ())

(define (all-statuss)
  (filter enable? (make-kahua-collection <status>)))

(define-method has? ((unit <unit>) (status <status>))
  (if (memq status (statuss-of unit)) #t #f))

;; type property
;;
(define-class <type> (<property-base>)
  ())

(define (all-types)
  (filter enable? (make-kahua-collection <type>)))

(define-method has? ((unit <unit>) (type <type>))
  (if (memq type (types-of unit)) #t #f))

;; categories property
;;
(define-class <category> (<property-base>)
  ())

(define (all-categories)
  (filter enable? (make-kahua-collection <category>)))

(define-method has? ((unit <unit>) (category <category>))
  (if (memq category (categories-of unit)) #t #f))

;; errorlog class
;;
(define-class <errorlog> (<kahua-persistent-base>)
  ((ctime            :allocation :persistent :init-keyword :ctime
		     :init-thunk sys-time :accessor ctime-of)
   (category         :allocation :persistent :init-keyword :category
		     :init-value "" :accessor category-of)
   (level            :allocation :persistent :init-keyword :level
		     :init-value 0 :accessor level-of)
   (message          :allocation :persistent :init-keyword :message
		     :init-value "" :accessor message-of)
   ))

(define (error-log-write cat lev msg)
  (make <errorlog>
    :category cat
    :level lev
    :message msg))

;;
;;
(define (id-list->obj-list class ids)
  (map (lambda (id)
	 (and id (find-kahua-instance class id)))
       ids))

(define (id->obj class id)
  (and id (find-kahua-instance class id)))
